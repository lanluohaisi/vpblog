# js高级程序设计(第四版)

::: tip
记录下重点的，平常易忽略的、以及平常不太了解的知识，对于一些很基础的语法，不太会涉及
:::

## 基础知识

1. ECMA-262第6版，俗称es6、es2015 或 es Harmony(和谐版)，于2015年6月发布。  

2. script标签:
    - async: 表示应该立即开始下载脚本，但不能阻止其他页面动作  
    - defer: 表示脚本可以延迟到文档完全被解析和显示之后再执行  
    - crossorigin: 配置相关请求的cors设置，默认不使用cors，'anonymous'配置文件请求不必设置凭据标识，'use-credentials'设置凭据标识，意味着出站请求会包含凭据  
    - integrity: 允许比对接收到的资源和指定的加密签名以验证子资源完整性，如不匹配，则页面会报错，脚本不会执行，这个属性可以用于确保内容分发网络(cdn)不会提供恶意内容

3. script元素可以包含来自外部域名的js文件，这个初始的请求不受浏览器同源策略限制，但返回并被执行的js则受限制

4. let、var: let声明的范围是块作用域，而var声明的范围是函数作用域；let声明的变量不会在作用域中被提升；let循环中，js引擎再后台会为每个迭代循环声明一个新的迭代变量

5. typeof: 
```js
typeof undefined // undefined
typeof null  // object
```

6. Symbol类型: 符号是原始值，且符号实例是惟一的，不可变的。如果允许的部分需要共享和重用符号实例，使用`Symbol.for()`方法  

7. Symbol常用内置符号:
    - Symbol.asyncIterator: 用于for-await-of循环  
    - Symbol.hasInstance  
    - Symbol.isConcatSpreadable
    - Symbol.iterator: 一个方法，该方法返回对象默认的迭代器，由for-of使用
    - Symbol.toPrimitive: 一个方法，该方法将对象转换为对应的原始值
    - Symbol.match、Symbol.replace、Symbol.search、Symbol.split: 均由String.prototype上对应的方法调用
    ```js
    class FooReplacer {
      static [Symbol.replace](target, replacement) {
        return target.split('foo').join(replacement);
      }
    }
    console.log('barfoobaz'.replace(FooReplacer, 'qux')); // "barquxbaz"
    class StringReplacer {
      constructor(str) {
        this.str = str;
      }
      [Symbol.replace](target, replacement) {
        return target.split(this.str).join(replacement);
      }
    }
    console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux')); // "barquxbaz"
    ```
8. 位操作符: ECMA中所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位~~

9. for-in语句是一种严格迭代语句，用于枚举对象中的非符号键属性，所以可枚举属性都会返回，但返回顺序可能会因浏览器而异。

10. switch的default关键字用于在任何条件都没有满足时指定默认执行的语句(相当于else语句)

11. 垃圾回收: 标记清理和引用计数，最佳实践是把不想要得属性设置为null  
    - 标记清理: 最常用策略，垃圾回收程序运行的时候，会标记内存中存储的所有变量，然后他会将所有再上下文中的变量以及被在上下文中变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的了，随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存。
    - 引用计数: 其思路是对每个值都记录它被引用的次数

12. 正则需要转义的元字符；RegExp构造函数参数，所有的元字符都必须二次转义，包括转义字符序列  
```js
( [ { \ ^ $ | } ] ) ? * + .
/\[bc\]at/  对应的字符串为 '\\[bc\\]at'
/\w\\hello\\123/  对应的字符串为 '\\w\\\\hello\\\\123'
```

13. RegExp实例方法: exec() 和 test()
  ```js
  let text = "cat, bat";
  let pattern = /.at/g; // 只有模式上设置了g标记，则会每次调用exec() 都会在字符串中向前搜索下一个匹配项
  let result = null;

  while((result = pattern.exec(text)) != null){
    console.log(result, result.index, pattern.lastIndex);
  }
  // ["cat", index: 0, input: "cat, bat", groups: undefined] 0 3
  // ["bat", index: 5, input: "cat, bat", groups: undefined] 5 8
  ```

14. String
    - 3个conf字符串中提取子字符串的方法: slice()、substr()、substring()；
    1）均接收一或两个参数，对slice 和 substring来说，第二个参数是提取结束的位置(即该位置之前的字符会被提取出来)。对sustr而言，第二个参数表示返回的字符串数量；
    2）当某个参数是负值时，slice将所有负值参数都当成字符串长度加上负参数值，而substr则将第一个负参数值当成字符串长度加上该值，第二个负参数值转换为0，substring会将所有负值转换为0。
    ```js
    let stringValue = "hello world";
    console.log(stringValue.slice(3, 7));     // "lo w"
    console.log(stringValue.substring(3,7));  // "lo w"
    console.log(stringValue.substr(3, 7));    // "lo 

    console.log(stringValue.slice(3, -4));      // "lo w" 相当于 slice(3, 7)
    console.log(stringValue.substring(3, -4));  // "hel" 相当于 substring(3, 0)，等价于 substring(0, 3)，因为这个方法会将较小的参数作为起点
    console.log(stringValue.substr(3, -4));     // "" 
    ```
    - es6 新增了3个用于判断字符串是否包含另一个字符串的方法: startWidth()、endsWith()、includes()
    - repeat()、padStart()、padEnd()
    - 字符串模式匹配方法: match() search() replace() split()

15. encodeURI() 不会编码属于URL组件的特殊字符，比如冒号、斜杆、问号、井号，而encodeURIComponent()会编码所有它发现的所有非标准字符

16. es6新增的用于创建数组的静态方法：from() 和 of()。
  1）from() 用于将类数组结构转换为数组实例，第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构，第二个可选映射函数，这个函数可以直接增强新数组的值，可选第三参数用于指定映射函数的this值，但这个this再箭头函数里面不适用
  2）of()用于将一组参数转换为数组实例。可用于替换es6之前的Array.prototype.slice.call(arguments)
  ```js
  const iter = {
    * [Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    }
  }
  console.log(Array.from(iter)); // [1, 2, 3]

  function getArgsArray() {
    return Array.from(arguments);
  }
  console.log(getArgsArray(1, 2, 3, 4));  // [1, 2, 3, 4]

  const arrayLikeObject = {
    0: 1,
    1: 2, 
    2: 3,
    3: 4,
    length: 4
  };
  console.log(Array.from(arrayLikeObject));  // [1, 2, 3, 4] 

  const a1 = [1, 2, 3, 4];
  const a2 = Array.from(a1, x => x**2); // 求幂运算符（**）IE不支持
  const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
  console.log(a2);  // [1, 4, 9, 16] 
  console.log(a3);  // [1, 4, 9, 16] 
  ```
17. Array实例方法: keys()、values()、entries()、copyWithin()、fill()、push()、pop()、unshift()、shift()、reverse()、sort()、concat()、 slice()、splice()、find()、findIndex()、every()、filter()、forEach()、map()、some()、reduce()、reduceRight()
  ```js
  // sort->如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，返回0；如果第一个参数应该排在第二个参数后面，就返回正值
  let values = [0, 1, 5, 3, 2, 7, 4];
  values.sort((a, b) => a < b ? -1 : a > b ? 1 : 0); // 大于0交换
  // 等价于 values.sort((a, b) => a - b); // 大于0交换
  console.log(values); // [0, 1, 2, 3, 4, 5, 7]

  // 从ints中复制索引5开始的内容，插入到索引0开始的位置
  let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  ints.copyWithin(0, 5);
  console.log(ints);  // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]


  let values1 = [1, 2, 3, 4, 5];
  let sum = values1.reduce((prev, cur, index, array) => prev + cur);
  console.log(sum);  // 15
  ```

18. ArrayBuffer是所有定型数组及视图引用的基本单位，定型数组是除了DataView视图外的另一种形式的视图
  ```js
  const source = Int16Array.of(2, 4, 6, 8);
  // Copy the array from index 2 on
  const halfCopy = source.subarray(2);
  console.log(halfCopy);  // [6, 8]

  const container = new Int16Array(8);
  // Copy in typed array into first four values
  // Offset default to an index of 0
  container.set(Int8Array.of(1, 2, 3, 4));
  alert(container);  // [1,2,3,4,0,0,0,0]
  ``` 

19. Map: 实例方法: set()、get()、has()、size属性、delete()、clear() entries() keys() value() ；与Object只能用数值、字符串或符号作为键不同，Map可以使用任何Js数据类型作为键；Map实例会维护键值对的插入顺序

20. WeakMap: 弱映射；弱映射中的键只能是Object 或者继承自Object的类型；因为WeakMap中的键/值对在任何时候都可能销毁，所以没有提供迭代其键/值对的能力。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取到值。

21. Set: 实例方法: add()、has()、size属性、delete()、clear() entries() keys() value() ；Set会维护值插入时的顺序，因此支持按顺序迭代；WeakSet同WeakMap类似。

## 进阶内容

1. 迭代器：
  ```js
  let arr = ['foo', 'bar'];
  let iter = arr[Symbol.iterator]();
  console.log(iter.next());  // { done: false, value: 'foo' }
  console.log(iter.next());  // { done: false, value: 'bar' }
  console.log(iter.next());  // { done: true, value: undefined }
  console.log(iter.next());  // { done: true, value: undefined }

  // Symbol.iterator属于引用的工厂函数会返回相同的迭代器
  let arr = ['foo', 'bar', 'baz'];
  let iter1 = arr[Symbol.iterator]();

  console.log(iter1[Symbol.iterator]);  // f values() { [native code] }
  let iter2 = iter1[Symbol.iterator]();
  console.log(iter1 === iter2);         // true


  // 自定义迭代器
  class Counter {
    constructor(limit) {
      this.limit = limit;
    }
    [Symbol.iterator]() {
      let count = 1;
      let limit = this.limit;
      return {
        next() {
          if (count <= limit) {
            return { done: false, value: count++ };
          } else {
            return { done: true, value: undefined };
          }
        }
      }
    }
  }
  let counter = new Counter(3);
  for(let i of counter) { console.log(i); }
  // 1
  // 2
  // 3
  ```
2. 生成器：拥有在一个函数块内暂停和恢复代码执行的能力；调用生成器函数会产生一个生成器对象，生成器对象也实现了Iterator接口，因此具有next()方法；yield 关键字可以让生成器停止和开始执行，停止执行的生成器函数只能通过在生成器对象上调用next()方法恢复执行。
  ```js
  function* generatorFn() {
    yield 'biz';
    yield 'qoo';
    return yield 'foo';
  }
  let generatorObject = generatorFn();
  console.log(generatorObject.next());       // { done: false, value: 'biz' }
  console.log(generatorObject.next('111'));  // { done: false, value: 'qoo' }
  console.log(generatorObject.next('bar'));  // { done: false, value: 'foo' } 
  console.log(generatorObject.next('112'));  // { done: true, value: '112' } 

  // 生成器作为默认迭代器 以及 yield* 
  class Foo {
    constructor() {
      this.values = [1, 2, 3];
    }
    * [Symbol.iterator]() {
      yield* this.values;
    }
  }
  for (const x of f) {
    console.log(x);
  }
  // 1
  // 2
  // 3

  // 提前终止迭代器
  function* generatorFun() {
    for (const x of [1, 2, 3]) { // 这个for-of相当于上面的 yield* [1, 2, 3]
      yield x;
    }
  }
  const g = generatorFun();
  for (const x of g) {
    console.log(x);
    if (x > 1) {
      console.log(g.return(4));
    }
  }
  // 1
  // 2
  // {value: 4, done: true}
  ```

3. 对象属性类型:
    - 数据属性：值(value，默认undifined，属性实际的值) 、可写性(writable，表示属性值是否可被修改)、可枚举(enumerable，默认true，是否可通过for-in循环返回)、可配置(configurable，默认true，是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改成访问器属性);
    >注意调用Object.defineProperty()时，writable、enumerable、configurable的值如果不设定，则都默认false;
    - 访问器属性:  读取(get)、写入(set)、可枚举性(enumerable，默认true)、可配置(configurable)；
    ```js
    let person = {};
    Object.defineProperty(person, "name", {
      writable: false, // 不设置这行，也会是false
      value: "Nicholas"
    });
    console.log(person.name);  // "Nicholas"
    person.name = "Greg";
    console.log(person.name);  // "Nicholas"

    let book = {
      year_: 2017,
      edition: 1
    };
      
    Object.defineProperty(book, "year", {
      get() {
        return this.year_;
      },
      set(newValue) {
        if (newValue > 2017) {
          this.year_ = newValue;
          this.edition += newValue - 2017;
        }
      }
    });
    book.year = 2018;
    console.log(book.edition);  // 2
    ```

4. 简写方法名
  ```js
  let person = {
    name_: '',
    get name() {
      return this.name_;
    },
    set name(name) {
      this.name_ = name;
    },
    sayName() {
      console.log(`My name is ${this.name_}`);
    }
  };

  person.name = 'Matt';
  person.sayName();  // My name is Matt
  ```

5. 对象解构
  ```js
  let person = {
    name: 'Matt',
    age: 27
  };

  let { name: personName } = person;
  let { age } = person;
  console.log(personName);  // Matt
  console.log(age);   // 27 
  ```

6. 创建对象: 一步一步渐进优化
    - 工厂模式: 
    ```js
    function createPerson(name, age, job) {
      let o = new Object();
      o.name = name;
      o.age = age;
      o.job = job;
      o.sayName = function() {
        console.log(this.name);
      };  
      return o;
    }
    let person1 = createPerson("Nicholas", 29, "Software Engineer");
    let person2 = createPerson("Greg", 27, "Doctor");
    ```
    - 构造函数模式:
    ```js
    function Person(name, age, job){
      this.name = name;
      this.age = age;
      this.job = job;
      this.sayName = function() {
        console.log(this.name);
      };  
    }
    let person1 = new Person("Nicholas", 29, "Software Engineer");
    let person2 = new Person("Greg", 27, "Doctor");
    person1.sayName();  // Nicholas
    person2.sayName();  // Greg
    ```
    > 构造函数new执行原理: 使用new操作符调用构造函数，会执行以下操作：1）再内存中创建一个新对象；2）这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性；3）函数内部的this被赋值为这个新对象；4）执行构造函数内部的代码；5）构造函数返回非空，则返回该对象，否则返回刚创建的新对象；
    ```js
    function create() {
      // 创建一个空的对象
      let obj = new Object();
      // 获得构造函数
      let Con = [].shift.call(argument);
      // 链接到原型
      obj.__proto__ = Con.prototype;
      // 绑定 this，执行构造函数
      let result = Con.apply(obj, arguments);
      // 确保 new 出来的是个对象
      return typeof result === 'object' ? result : obj;
    }
    ```
    - 原型模式: 
    
