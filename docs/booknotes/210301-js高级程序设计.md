# js高级程序设计(第四版)(210301)

::: tip
记录下重点的，平常易忽略的、以及平常不太了解的知识，对于一些很基础的语法，不太会涉及
:::

## 基础知识

1. ECMA-262第6版，俗称es6、es2015 或 es Harmony(和谐版)，于2015年6月发布。  

2. script标签:
    - async: 表示应该立即开始下载脚本，但不能阻止其他页面动作  
    - defer: 表示脚本可以延迟到文档完全被解析和显示之后再执行  
    - crossorigin: 配置相关请求的cors设置，默认不使用cors，'anonymous'配置文件请求不必设置凭据标识，'use-credentials'设置凭据标识，意味着出站请求会包含凭据  
    - integrity: 允许比对接收到的资源和指定的加密签名以验证子资源完整性，如不匹配，则页面会报错，脚本不会执行，这个属性可以用于确保内容分发网络(cdn)不会提供恶意内容

3. script元素可以包含来自外部域名的js文件，这个初始的请求不受浏览器同源策略限制，但返回并被执行的js则受限制

4. let、var: let声明的范围是块作用域，而var声明的范围是函数作用域；let声明的变量不会在作用域中被提升；let循环中，js引擎再后台会为每个迭代循环声明一个新的迭代变量

5. typeof: 
```js
typeof undefined // undefined
typeof null  // object
```

6. Symbol类型: 符号是原始值，且符号实例是惟一的，不可变的。如果允许的部分需要共享和重用符号实例，使用`Symbol.for()`方法  

7. Symbol常用内置符号:
    - Symbol.asyncIterator: 用于for-await-of循环  
    - Symbol.hasInstance  
    - Symbol.isConcatSpreadable
    - Symbol.iterator: 一个方法，该方法返回对象默认的迭代器，由for-of使用
    - Symbol.toPrimitive: 一个方法，该方法将对象转换为对应的原始值
    - Symbol.match、Symbol.replace、Symbol.search、Symbol.split: 均由String.prototype上对应的方法调用
    ```js
    class FooReplacer {
      static [Symbol.replace](target, replacement) {
        return target.split('foo').join(replacement);
      }
    }
    console.log('barfoobaz'.replace(FooReplacer, 'qux')); // "barquxbaz"
    class StringReplacer {
      constructor(str) {
        this.str = str;
      }
      [Symbol.replace](target, replacement) {
        return target.split(this.str).join(replacement);
      }
    }
    console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux')); // "barquxbaz"
    ```
8. 位操作符: ECMA中所有数值都以IEEE 754 64位格式存储，但位操作并不直接应用到64位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为64位~~

9. for-in语句是一种严格迭代语句，用于枚举对象中的非符号键属性，所以可枚举属性都会返回，但返回顺序可能会因浏览器而异。

10. switch的default关键字用于在任何条件都没有满足时指定默认执行的语句(相当于else语句)

11. 垃圾回收: 标记清理和引用计数，最佳实践是把不想要得属性设置为null  
    - 标记清理: 最常用策略，垃圾回收程序运行的时候，会标记内存中存储的所有变量，然后他会将所有再上下文中的变量以及被在上下文中变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的了，随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存。
    - 引用计数: 其思路是对每个值都记录它被引用的次数

12. 正则需要转义的元字符；RegExp构造函数参数，所有的元字符都必须二次转义，包括转义字符序列  
```js
( [ { \ ^ $ | } ] ) ? * + .
/\[bc\]at/  对应的字符串为 '\\[bc\\]at'
/\w\\hello\\123/  对应的字符串为 '\\w\\\\hello\\\\123'
```

13. RegExp实例方法: exec() 和 test()
  ```js
  let text = "cat, bat";
  let pattern = /.at/g; // 只有模式上设置了g标记，则会每次调用exec() 都会在字符串中向前搜索下一个匹配项
  let result = null;

  while((result = pattern.exec(text)) != null){
    console.log(result, result.index, pattern.lastIndex);
  }
  // ["cat", index: 0, input: "cat, bat", groups: undefined] 0 3
  // ["bat", index: 5, input: "cat, bat", groups: undefined] 5 8
  ```

14. String
    - 3个conf字符串中提取子字符串的方法: slice()、substr()、substring()；
    1）均接收一或两个参数，对slice 和 substring来说，第二个参数是提取结束的位置(即该位置之前的字符会被提取出来)。对sustr而言，第二个参数表示返回的字符串数量；
    2）当某个参数是负值时，slice将所有负值参数都当成字符串长度加上负参数值，而substr则将第一个负参数值当成字符串长度加上该值，第二个负参数值转换为0，substring会将所有负值转换为0。
    ```js
    let stringValue = "hello world";
    console.log(stringValue.slice(3, 7));     // "lo w"
    console.log(stringValue.substring(3,7));  // "lo w"
    console.log(stringValue.substr(3, 7));    // "lo 

    console.log(stringValue.slice(3, -4));      // "lo w" 相当于 slice(3, 7)
    console.log(stringValue.substring(3, -4));  // "hel" 相当于 substring(3, 0)，等价于 substring(0, 3)，因为这个方法会将较小的参数作为起点
    console.log(stringValue.substr(3, -4));     // "" 
    ```
    - es6 新增了3个用于判断字符串是否包含另一个字符串的方法: startWidth()、endsWith()、includes()
    - repeat()、padStart()、padEnd()
    - 字符串模式匹配方法: match() search() replace() split()

15. encodeURI() 不会编码属于URL组件的特殊字符，比如冒号、斜杆、问号、井号，而encodeURIComponent()会编码所有它发现的所有非标准字符

16. es6新增的用于创建数组的静态方法：from() 和 of()。
  1）from() 用于将类数组结构转换为数组实例，第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构，第二个可选映射函数，这个函数可以直接增强新数组的值，可选第三参数用于指定映射函数的this值，但这个this再箭头函数里面不适用
  2）of()用于将一组参数转换为数组实例。可用于替换es6之前的Array.prototype.slice.call(arguments)
  ```js
  const iter = {
    * [Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    }
  }
  console.log(Array.from(iter)); // [1, 2, 3]

  function getArgsArray() {
    return Array.from(arguments);
  }
  console.log(getArgsArray(1, 2, 3, 4));  // [1, 2, 3, 4]

  const arrayLikeObject = {
    0: 1,
    1: 2, 
    2: 3,
    3: 4,
    length: 4
  };
  console.log(Array.from(arrayLikeObject));  // [1, 2, 3, 4] 

  const a1 = [1, 2, 3, 4];
  const a2 = Array.from(a1, x => x**2); // 求幂运算符（**）IE不支持
  const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
  console.log(a2);  // [1, 4, 9, 16] 
  console.log(a3);  // [1, 4, 9, 16] 
  ```
17. Array实例方法: keys()、values()、entries()、copyWithin()、fill()、push()、pop()、unshift()、shift()、reverse()、sort()、concat()、 slice()、splice()、find()、findIndex()、every()、filter()、forEach()、map()、some()、reduce()、reduceRight()
  ```js
  // sort->如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，返回0；如果第一个参数应该排在第二个参数后面，就返回正值
  let values = [0, 1, 5, 3, 2, 7, 4];
  values.sort((a, b) => a < b ? -1 : a > b ? 1 : 0); // 大于0交换
  // 等价于 values.sort((a, b) => a - b); // 大于0交换
  console.log(values); // [0, 1, 2, 3, 4, 5, 7]

  // 从ints中复制索引5开始的内容，插入到索引0开始的位置
  let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  ints.copyWithin(0, 5);
  console.log(ints);  // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]


  let values1 = [1, 2, 3, 4, 5];
  let sum = values1.reduce((prev, cur, index, array) => prev + cur);
  console.log(sum);  // 15
  ```

18. ArrayBuffer是所有定型数组及视图引用的基本单位，定型数组是除了DataView视图外的另一种形式的视图
  ```js
  const source = Int16Array.of(2, 4, 6, 8);
  // Copy the array from index 2 on
  const halfCopy = source.subarray(2);
  console.log(halfCopy);  // [6, 8]

  const container = new Int16Array(8);
  // Copy in typed array into first four values
  // Offset default to an index of 0
  container.set(Int8Array.of(1, 2, 3, 4));
  alert(container);  // [1,2,3,4,0,0,0,0]
  ``` 

19. Map: 实例方法: set()、get()、has()、size属性、delete()、clear() entries() keys() value() ；与Object只能用数值、字符串或符号作为键不同，Map可以使用任何Js数据类型作为键；Map实例会维护键值对的插入顺序

20. WeakMap: 弱映射；弱映射中的键只能是Object 或者继承自Object的类型；因为WeakMap中的键/值对在任何时候都可能销毁，所以没有提供迭代其键/值对的能力。因为不可能迭代，所以也不可能在不知道对象引用的情况下从弱映射中取到值。

21. Set: 实例方法: add()、has()、size属性、delete()、clear() entries() keys() value() ；Set会维护值插入时的顺序，因此支持按顺序迭代；WeakSet同WeakMap类似。

## 进阶内容

1. 迭代器：
  ```js
  let arr = ['foo', 'bar'];
  let iter = arr[Symbol.iterator]();
  console.log(iter.next());  // { done: false, value: 'foo' }
  console.log(iter.next());  // { done: false, value: 'bar' }
  console.log(iter.next());  // { done: true, value: undefined }
  console.log(iter.next());  // { done: true, value: undefined }

  // Symbol.iterator属于引用的工厂函数会返回相同的迭代器
  let arr = ['foo', 'bar', 'baz'];
  let iter1 = arr[Symbol.iterator]();

  console.log(iter1[Symbol.iterator]);  // f values() { [native code] }
  let iter2 = iter1[Symbol.iterator]();
  console.log(iter1 === iter2);         // true


  // 自定义迭代器
  class Counter {
    constructor(limit) {
      this.limit = limit;
    }
    [Symbol.iterator]() {
      let count = 1;
      let limit = this.limit;
      return {
        next() {
          if (count <= limit) {
            return { done: false, value: count++ };
          } else {
            return { done: true, value: undefined };
          }
        }
      }
    }
  }
  let counter = new Counter(3);
  for(let i of counter) { console.log(i); }
  // 1
  // 2
  // 3
  ```
2. 生成器：拥有在一个函数块内暂停和恢复代码执行的能力；调用生成器函数会产生一个生成器对象，生成器对象也实现了Iterator接口，因此具有next()方法；yield 关键字可以让生成器停止和开始执行，停止执行的生成器函数只能通过在生成器对象上调用next()方法恢复执行。
  ```js
  function* generatorFn() {
    yield 'biz';
    yield 'qoo';
    return yield 'foo';
  }
  let generatorObject = generatorFn();
  console.log(generatorObject.next());       // { done: false, value: 'biz' }
  console.log(generatorObject.next('111'));  // { done: false, value: 'qoo' }
  console.log(generatorObject.next('bar'));  // { done: false, value: 'foo' } 
  console.log(generatorObject.next('112'));  // { done: true, value: '112' } 

  // 生成器作为默认迭代器 以及 yield* 
  class Foo {
    constructor() {
      this.values = [1, 2, 3];
    }
    * [Symbol.iterator]() {
      yield* this.values;
    }
  }
  for (const x of f) {
    console.log(x);
  }
  // 1
  // 2
  // 3

  // 提前终止迭代器
  function* generatorFun() {
    for (const x of [1, 2, 3]) { // 这个for-of相当于上面的 yield* [1, 2, 3]
      yield x;
    }
  }
  const g = generatorFun();
  for (const x of g) {
    console.log(x);
    if (x > 1) {
      console.log(g.return(4));
    }
  }
  // 1
  // 2
  // {value: 4, done: true}
  ```

3. 对象属性类型:
    - 数据属性：值(value，默认undifined，属性实际的值) 、可写性(writable，表示属性值是否可被修改)、可枚举(enumerable，默认true，是否可通过for-in循环返回)、可配置(configurable，默认true，是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改成访问器属性);
    >注意调用Object.defineProperty()时，writable、enumerable、configurable的值如果不设定，则都默认false;
    - 访问器属性:  读取(get)、写入(set)、可枚举性(enumerable，默认true)、可配置(configurable)；
    ```js
    let person = {};
    Object.defineProperty(person, "name", {
      writable: false, // 不设置这行，也会是false
      value: "Nicholas"
    });
    console.log(person.name);  // "Nicholas"
    person.name = "Greg";
    console.log(person.name);  // "Nicholas"

    let book = {
      year_: 2017,
      edition: 1
    };
      
    Object.defineProperty(book, "year", {
      get() {
        return this.year_;
      },
      set(newValue) {
        if (newValue > 2017) {
          this.year_ = newValue;
          this.edition += newValue - 2017;
        }
      }
    });
    book.year = 2018;
    console.log(book.edition);  // 2
    ```

4. 简写方法名
  ```js
  let person = {
    name_: '',
    get name() {
      return this.name_;
    },
    set name(name) {
      this.name_ = name;
    },
    sayName() {
      console.log(`My name is ${this.name_}`);
    }
  };

  person.name = 'Matt';
  person.sayName();  // My name is Matt
  ```

5. 对象解构
  ```js
  let person = {
    name: 'Matt',
    age: 27
  };

  let { name: personName } = person;
  let { age } = person;
  console.log(personName);  // Matt
  console.log(age);   // 27 
  ```

6. 创建对象: 一步一步渐进优化
    - 工厂模式: 
    ```js
    function createPerson(name, age, job) {
      let o = new Object();
      o.name = name;
      o.age = age;
      o.job = job;
      o.sayName = function() {
        console.log(this.name);
      };  
      return o;
    }
    let person1 = createPerson("Nicholas", 29, "Software Engineer");
    let person2 = createPerson("Greg", 27, "Doctor");
    ```
    - 构造函数模式:
    ```js
    function Person(name, age, job){
      this.name = name;
      this.age = age;
      this.job = job;
      this.sayName = function() {
        console.log(this.name);
      };  
    }
    let person1 = new Person("Nicholas", 29, "Software Engineer");
    let person2 = new Person("Greg", 27, "Doctor");
    person1.sayName();  // Nicholas
    person2.sayName();  // Greg
    ```
    > 构造函数new执行原理: 使用new操作符调用构造函数，会执行以下操作：1）再内存中创建一个新对象；2）这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性；3）函数内部的this被赋值为这个新对象；4）执行构造函数内部的代码；5）构造函数返回非空，则返回该对象，否则返回刚创建的新对象；
    ```js
    function create() {
      // 创建一个空的对象
      let obj = new Object();
      // 获得构造函数
      let Con = [].shift.call(argument);
      // 链接到原型
      obj.__proto__ = Con.prototype;
      // 绑定 this，执行构造函数
      let result = Con.apply(obj, arguments);
      // 确保 new 出来的是个对象
      return typeof result === 'object' ? result : obj;
    }
    ```
    - 原型模式:  
      1）无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性(指向原型对象)。默认情况下，所有的原型对象字段会获得一个名为constructor的属性，指回与之关联的构造函数；  
      2）在自定义构造函数时，原型对象默认只会获得constructor属性，其他所有的方法继承自Object。每次调用构造函数创建一个新实例，这个实例内部[[Prototype]]指针就会被赋值为`构造函数的原型对象`。脚本中没有访问这个[[Prototype]]特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。关键在于理解这一点: `实例与构造函数原型直接有直接联系，但实例与构造函数直接没有。`  
      3) Object.create()创建一个对象，并指定原型。  
      4）实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象时也不会改变，重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。  
      ```js
      function People() {}
      console.log(Person.prototype);
      // {
      //   constructor: f Person(),
      //   __proto__: Object
      // }
      console.log(Person.prototype.constructor === Person); // true
      /**
       * 正常的原型链都会终止与Object的原型对象
      * Object 原型的原型 是 null.
      */
      console.log(Person.prototype.__proto__ === Object.prototype);    // true
      console.log(Person.prototype.__proto__.constructor === Object);  // true
      console.log(Person.prototype.__proto__.__proto__ === null);      // true

      let person1 = new Person();
      console.log(person1.__proto__ === Person.prototype);    // true
      conosle.log(person1.__proto__.constructor === Person);  // true
      console.log(person1 instanceof Person);           // true
      ```
      4）遍历属性范围  
          - in操作符：单独使用时，in操作符会在可以通过对象访问属性时返回true，无论该属性是在实例上还是原型上；
          - hasOwnProperty()只有属性存在于实例上才返回true；
          - for-in循环中，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性；
          - Object.keys()返回对象上所有可枚举的实例属性；
          - Object.getOwnPropertyNames()获取所有实例属性，无论是否可枚举；

7. 继承  
    - 原型链：每个构造函数都有一个原型对象，原型有一个属性指向构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数，这样再实例和原型之间构造了一条原型链。这就是原型链的基本构想。  
    - 任何函数的默认原型都是一个`Object的实例`，这意味着这个实例有一个内部指针指向Object.prototype。
    - 原型链继承：问题: 1）父类的实例属性变成了子类的原型属性  2）子类在实例化的时候不能给父类型的构造函数传参  
      ```js
      function SuperType() {
        this.colors = ["red", "blue", "green"];
      }

      function SubType() {}

      // inherit from SuperType
      SubType.prototype = new SuperType();

      let instance1 = new SubType();
      instance1.colors.push("black");
      console.log(instance1.colors);  // "red,blue,green,black"

      let instance2 = new SubType();
      console.log(instance2.colors);  // "red,blue,green,black" 
      ```
    - 盗用构造函数继承: 不会变成原型属性，同时可以传参；缺点是必须在构造函数中定义方法，也即是使用构造函数自定义类型的问题。
      ```js
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }
      function SubType(name, age){  
        SuperType.call(this, name);
        this.age = age; // 实例属性
      }
      let instance1 = new SubType('jack', 18);
      console.log(instance1.name);  // 'jack'
      ```
    - 组合继承: 综合了原型链和盗用构造函数，可以解决上面的缺点，但是父类的构造函数会被调用两次
      ```js
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }
      SuperType.prototype.sayName = function() {
        console.log(this.name);
      };

      function SubType(name, age){  
        SuperType.call(this, name);      // second call to SuperType()
        this.age = age;
      }

      SubType.prototype = new SuperType();   // first call to SuperType()
      SubType.prototype.constructor = SubType;
      SubType.prototype.sayAge = function() {
        console.log(this.age);
      };

      let instance1 = new SubType("Nicholas", 29);
      instance1.colors.push("black");
      console.log(instance1.colors);  // "red,blue,green,black"
      instance1.sayName();            // "Nicholas";
      instance1.sayAge();             // 29
                
      let instance2 = new SubType("Greg", 27);
      console.log(instance2.colors);  // "red,blue,green"
      instance2.sayName();            // "Greg";
      instance2.sayAge();             // 27
      ```
    - 原型式继承：思想是不定义类型也可以通过原型实现对象间的信息共享；但要注意属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的~
      ```js
      // 相对于Object.create()只有一个参数情况
      function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
      }
      ```
    - 寄生式继承：创建一个实现继承的函数，以某种方式增强对象，然后返回对象
      ```js
      function createAnother(original) {
        let clone = object(original);
        clone.sayHi = function() {
          console.log('hi');
        }
        return clone;
      }
      ```
    - 寄生式组合继承：基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副部。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。
      ```js
      function inheritPrototype(subType, superType) {
        let prototype = object(superType.prototype);
        subType.protoType = prototype;
        prototype.constructor = subType;
      }
      function SuperType(name) {
        this.name = name;
        this.colors = ["red", "blue", "green"];
      }
      SuperType.prototype.sayName = function() {
        console.log(this.name);
      };

      function SubType(name, age){  
        SuperType.call(this, name);
        this.age = age;
      }
      inheritPrototype(SubType, SuperType);
      SubType.prototype.sayAge = function() {
        console.log(this.age);
      };
      ```

8. 类
    - 类标识符有prototype属性，而这个原型也有一个constructor属性指向类本身；  
    - 实例成员：构造函数内部，可以为新创建的实例添加'自有'属性；
    - 原型方法与访问器：为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法；类定义也支持获取和设置访问器，语法和行为和普通对象一样；
    - 静态类方法：静态类成员在类定义中使用static关键字作为前缀，再静态成员中，this引用类自身；其他所有约定和原型成员一样；
    - 支持生成器方法，可以通过添加一个默认的迭代器，把类实例变成可迭代对象；
      ```js
      class Person {
        constructor() {
          this.nicknames = ['aa', 'bb', 'cc'];
        }
        *[Symbol.iterator] () {
          yield *this.nicknames.entries();
        }
        // 也可以只返回迭代器实例
        /**
        [Symbol.iterator] () {
          return this.nicknames.entries();
        }
        */
      }
      console.log(Person.prototype);
      // {
      //   constructor: class Person
      //   Symbol(Symbol.iterator): ƒ* [Symbol.iterator]()
      //   __proto__: Object
      // }
      let p = new Person();
      for (let [idx, nickname] of p) {
        console.log(idx, nickname);
      }
      // 0 "aa"
      // 1 "bb"
      // 2 "cc"
      ```
    - 继承：使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象；
        - 如果没有定义类构造函数，再实例化派生类时会调用super()，而且会传入所有派生类的参数；
        - 在类构造函数中，不能在调用super()之前引用this。
        - 如果在派生类中定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象。

9. 代理和反射
    - 代理是使用Proxy构造函数创建的，接收两个参数: 目标对象和处理程序对象。缺少其中任何一个参数都会抛出TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标。  
    - 空代理，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象；Proxy.prototype 是undifined；
    - 捕获器: 每个处理程序对象都可以包含多个捕获器，每个捕获器都对应一种基本操作，每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为；
    - 反射: 处理程序对象中所有可以捕获的方法都有对应的反射API方法，这些方法与捕获器具有相同的方法和函数签名，而且也具有与被拦截方法相同的行为；
      ```js
      const target = {
        foo: 'bar',
        baz: 'qux'
      };
      const handler = {
        // 目标对象、要查询的属性、代理对象
        get(trapTarget, property, reeceiver) {
          let dec = '';
          if (property === 'foo') {
            dec = '!!!';
          }
          return Reflect.get(...arguments) + dec;
        }
      }
      const proxy = new Proxy(target, handler);
      console.log(proxy.foo);  // bar!!!
      console.log(proxy.baz);  // qux
      ```
    - 可撤销代理: Proxy暴露了revocable()方法，支持撤销代理对象与目标对象的关联。撤销函数和代理对象是在实例化时同时生成的；
      ```js
      const target = {
        foo: 'bar'
      };
      const handler = {
        // 目标对象、要查询的属性、代理对象
        get(trapTarget, property, reeceiver) {
          return 'intercepted';
        }
      }
      const { proxy, revoke } = Proxy.revocable(target, handler);
      console.log(proxy.foo); // intercepted
      console.log(target.foo); // bar
      revoke();
      console.log(proxy.foo); // VM81:14 Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked
      ```
    - 13种代理捕获：
    1) 获取属性操作中被调用：get(target, property, receiver)  
    2) 设置属性值操作中被调用：set(target, property, value, receiver)  
    3) in操作符中被调用：has(target, property)  
    4) 在Object.defineProperty()中被调用：defineProperty(target, property, descriptor)  
    5) getOwnPropertyDescriptor(target, property)  
    6) deleteProperty(target, property)  
    7) 在Object.keys()及类似方法中被调用：ownKeys(target)  
    8) getPropertyOf(target)、setPropertyOf(target, prototype)、isExtensible()、preventExtensions()  
    9) 调用函数时被调用：apply(target, thisArg, argumentsList)  
    10) 在new操作符中被调用：construct(target, argumentsList, newTarget)  

10. 函数：
    - 箭头函数不能使用arguments、super 和 new.target, 也不能用作构造函数；此外箭头函数也没有peototype属性；  
    - 函数方法: apply() 、call()、bind()，两个方法都会以指定的this来调用函数，apply的第二个参数可以是Array实例，也可以是arguments对象，call方法则是逐个传递参数的；bind方法会创建一个新的函数实例，其this会绑定到传给bind()的对象；  
    - 尾调用优化:
      1) 代码在严格模式下执行  
      2) 外部函数的返回值是对尾调用函数的调用  
      3) 尾调用函数返回后不需要执行额外的逻辑  
      4) 尾调用函数不是引用外部函数作用域中自由变量的闭包  

11. 期约与异步函数：
    - Promise.prototype.then()接收最多两个参数，onResolved处理函数和onRejected处理函数；方法返回一个新的期约实例；  
    - 期约连锁与期约合成：
      ```js
      let p1 = new Promise((resolve, reject) => {
        console.log('p1 executor');
        setTimeout(resolve, 1000);
      });

      p1.then(() => new Promise((resolve, reject) => {
          console.log('p2 executor');
          setTimeout(resolve, 1000);
        }))
        .then(() => new Promise((resolve, reject) => {
          console.log('p3 executor');
          setTimeout(resolve, 1000);
        }))
        .then(() => new Promise((resolve, reject) => {
          console.log('p4 executor');
          setTimeout(resolve, 1000);
        }));

        // 期约合成
        function addTwo(x) {return x + 2;}
        function addThree(x) {return x + 3;}
        function addFive(x) {return x + 5;}

        function compose(...fns) {
          return (x) => fns.reduce((promise, fn) => promise.then(fn), Promise.resolve(x))
        }

        let addTen = compose(addTwo, addThree, addFive);
        addTen(8).then(console.log);  // 18
      ```
    - 异步函数：async 和 await；async始终返回期约对象；await 后面会被进行异步求值；

## BOM 和 DOM

1. BOM
    - window对象: 
      1) 页面视口大学，利用 window.innerWidth 和 window.innerHeight  
      2) 度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXOffset/window.scrollX 和 window.pageYOffset/window.scrollY  
      3) 滚动方法: scroll()、scrollTo()、scrollBy()
    - location对象：不仅保存着当前加载文档的信息，也保存着把URL解析为离散片段后能够通过属性访问的信息
      1) 属性：hash、host、hostname、href、pathname、port、protocol、search、username、password、origin  
    - navigator对象：通常用于确定浏览器类型（经常用的属性：userAgent、platform、plugins）
    - history对象：
      1) 状态管理api：pushState() 和 replaceState()，接收3个参数：一个state对象、一个新状态标题很一个可选的相对URL；pushState()执行后，状态信息会被推到历史记录中，浏览器地址栏也会改变以反映新的相对URL，但即使location.href返回的是地址栏中的内容，浏览器页不会向服务器发送请求；replaceState()则是更新状态不会创建新历史记录，只会覆盖当前状态。  

2. 客户端检测：能力检测与用户代理检测
3. DOM
    - 节点层级：document节点表示每个文档的根节点，根节点的唯一子节点是html元素，我们称之为文档元素（documentElement） 

    - node类型: 所有DOM节点类型都必须实现的；
      1) 属性：nodeType、nodeName、nodeValue  
      2) 节点关系属性：`childNodes`，包含一个类数组对象NodeList，注意NodeList是实时的活动对象；parentNode属性、previousSibling 和 nextSibling、firstChild、lastChild  
      3) 操纵节点：appendChild() 、 insertBefore() 、replaceChild() 、removeChild()、cloneNode() 、normalize() --处理文档子树中的文本节点  

    - Document类型(nodeType为9)：document
      1) document.documentElement、 document.body、 document.URL、document.domain、document.domain、document.title  
      2) document.getElementById()、document.getElementsByTagName()、document.getElementsByName()  
      3) document.anchors、document.forms、document.images、document.links  

    - Element类型(nodeType为1): document.createElement()创建
      1) getAttribute() setAttribute()、removeAttribute()、attributes属性  
      2) 元素的getElementsByTagName()  

    - Text类型(nodeType为3)：document.createTextNode()
    - DocumentFragment类型(nodeType为11)：
      ```js
      let fragment = document.createDocumentFragment();
      let ul = document.getElementById("myList");
      for (let i = 0; i < 3; ++i) {
        let li = document.createElement("li");
        li.appendChild(document.createTextNode(`Item ${i + 1}`));
        fragment.appendChild(li);
      }
      ul.appendChild(fragment);
      ```
    - 操纵表格
      ```js
      let table = document.createElement("table");
      table.border = 1;
      table.width = "100%";
      // create the tbody
      let tbody = document.createElement("tbody");
      table.appendChild(tbody);
      // create the first row
      tbody.insertRow(0);
      tbody.rows[0].insertCell(0);
      tbody.rows[0].cells[0].appendChild(document.createTextNode("Cell 1,1"));
      tbody.rows[0].insertCell(1);
      tbody.rows[0].cells[1].appendChild(document.createTextNode("Cell 2,1"));
      // create the second row
      tbody.insertRow(1);
      tbody.rows[1].insertCell(0);
      tbody.rows[1].cells[0].appendChild(document.createTextNode("Cell 1,2"));
      tbody.rows[1].insertCell(1);
      tbody.rows[1].cells[1].appendChild(document.createTextNode("Cell 2,2"));
      // add the table to the document body
      document.body.appendChild(table);
      ```
    - MutationObserver接口
      ```js
      document.body.innerHTML = '';

      let observer = new MutationObserver(
          (mutationRecords) => console.log(mutationRecords));
      // Create initial element
      document.body.appendChild(document.createElement('div'));
      // Observe the <body> subtree
      observer.observe(document.body, { attributes: true, subtree: true });
      // Modify <body> subtree
      document.body.firstChild.setAttribute('foo', 'bar');
      ```

4. DOM扩展: Selectors API 和 HTML5
    - querySelector() 和 querySelectorAll() 、matches() 
    - getElementsByClassName()、classList属性(具有操纵方法: add(val)、contains(val)、remove(val)、toggle(val) )
    - 焦点管理: `document.activeElement`始终包含当前拥有焦点的DOM元素；document.hasFocus()确定文档是否获得了焦点，就可以确定用户是否再操纵页面；
    - 自定义数据属性: 前缀`data-`格式；可以通过元素的dataset属性来访问；例如 属性 data-myname、data-myName可以通过myname访问，但要注意 data-my-name、data-My-Name 要通过myName来访问；
    - innerHTML属性 、outerHTML属性：注意: 通过innerHTML属性创建的script元素永远不会执行；
    - insertAdjacentHTML() 和 insetAdjacentText(): 接收两个参数：要掺入标记的位置和要插入的HTML或文本
      ```js
      // 'beforebegin'：元素自身的前面。
      // 'afterbegin'：插入元素内部的第一个子节点之前。
      // 'beforeend'：插入元素内部的最后一个子节点之后。
      // 'afterend'：元素自身的后面。
      element.insertAdjacentHTML('beforebegin', '<p>Hello world!</p>');
      ```
    - scrollIntoView(): 
      ```js
      // These behave identically
      document.forms[0].scrollIntoView(true); 
      document.forms[0].scrollIntoView({block: true});

      // This attempts to scroll the element smoothly into view:
      document.forms[0].scrollIntoView({behavior: 'smooth', block: true});
      ```
    - 专有扩展: children属性 以及 contains()、innerText属性  

5. DOM2 和 DOM3
  - style属性：任何支撑style属性的HTML元素在js中都有一个对应的style属性，其中包括HTML style属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式  
  - document.defaultView.getComputedStyle(element, pseudoElt) 与  window.getComputedStyle(element, pseudoElt): 一般情况下document.defaultView===window只有很特殊的浏览器的frame中不一致，所以目前不需要管了
  - 元素属性：
    1) offsetWidth、offsetHeight、offsetLeft、offsetTop、offsetParent；---只读属性offsetWidth、offsetHeight以css像素返回它的屏幕尺寸，包含边框和内边距，不包含外边距，offsetLeft、offsetTop属性来返回元素的x和y坐标，相对父元素(offsetParent元素)  
    2) clientWidth、clientHeight、clientLeft、clientTop; ---clientWidth、clientHeight不包含边框，只包含内容和内边距，同时也不包含滚动条。  
    3) scrollWidth、scrollHeight、scrollTop、scrollLeft；---scrollWidth、scrollHeight是元素的内容区域再加上任何溢出内容的尺寸；scrollTop、scrollLeft是可写属性，指定元素的滚动条位置；  

  - NodeIterator 和 TreeWalker: 从某个起点开始执行对DOM结构的深度优先遍历 
    1) 4个参数：遍历的根节点、数值代码，表示应该访问哪些节点、NodeFilter对象或者函数，表示是否接收或跳过特定节点、是否扩展实体引用  
    ```js
    let div = document.getElementById("div1");
    let filter = function(node) {
      return node.tagName.toLowerCase() == "li" ? 
        NodeFilter.FILTER_ACCEPT :
        NodeFilter.FILTER_SKIP;
    };
    let walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false);
    // 或者
    // let iterator = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT, filter, false);

    let node = walker.nextNode();
    while (node !== null) {
      console.log(node.tagName);     // output the tag name
      node = walker.nextNode();
    }

    ```
  - 范围：document.createRange()

6. 事件
    - dom0的事件处理程序属性、dom2的addEventListener()、removeEventListener()  
    - load事件：window对象的load事件、图片的load事件、script元素的load事件
    - window的对象上的scroll事件
    - 焦点事件：blur 和 focus，不冒泡，dom3新增focusin 和 focusout 
    - 鼠标和滚动事件：click、dblclick、mousedown、mouseenter、mouseleave、mousemove、mouseout、mouseover、mouseup 事件，以及 event.clientX、clientY、pageX、pageY、screenX、screenY
    - 键盘与输入事件：keydown、keypress、keyup 以及输入事件textInput
    - 合成事件：用于处理使用IME输入时的复杂输入序列，包括 compositionstart、compositionupdate、compositionend
    - html5事件：contextmenu事件、document的DOMContentLoaded事件、readystatechange事件、window对象的 pageshow 和 pagehide事件、window对象的hashchange事件
    - 设备事件：window对象的 orientationchange事件（window.orientation属性）、window对象的 deviceorientation事件、window对象的devicemotion对象
    - 触摸及手势事件：touchstart、touchmove、touchend、touchcancle事件 以及 gesturestart、gesturechange、gestureend
      ```js
      function handleTouchEvent(event) {
        // only for one touch
        if (event.touches.length == 1)
          let output = document.getElementById("output");
          switch(event.type) {
            case "touchstart":
              output.innerHTML += `<br>Touch started:` +
                                  `(${event.touches[0].clientX}` +
                                  ` ${event.touches[0].clientY})`;
              break;
            case "touchend":
              output.innerHTML += `<br>Touch ended:` +
                                  `(${event.changedTouches[0].clientX}` +
                                  ` ${event.changedTouches[0].clientY})`;
              break;
            case "touchmove":
              event.preventDefault();  // 阻止滚动
              output.innerHTML += `<br>Touch moved:` +
                                  `(${event.changedTouches[0].clientX}` +
                                  ` ${event.changedTouches[0].clientY})`;
              break;
          }
        }
      }
            
      document.addEventListener("touchstart", handleTouchEvent);
      document.addEventListener("touchend", handleTouchEvent);
      document.addEventListener("touchmove", handleTouchEvent);

      // 手势事件
      function handleGestureEvent(event) {    
        let output = document.getElementById("output");
        switch(event.type) {
          case "gesturestart":
            output.innerHTML += `Gesture started: rotation=${event.rotation}, scale=${event.scale}`;
            break;
          case "gestureend":
            output.innerHTML += `Gesture end: rotation=${event.rotation}, scale=${event.scale}`;
            break;
          case "gesturechange":
            output.innerHTML += `Gesture change: rotation=${event.rotation}, scale=${event.scale}`;
            break;
        }
      }
      document.addEventListener("gesturestart", handleGestureEvent, false);
      document.addEventListener("gestureend", handleGestureEvent, false);
      document.addEventListener("gesturechange", handleGestureEvent, false);
      ```
    - 模拟事件：document.createEvent()、dispatchEvent()
      ```js
      let btn = document.getElementById("myBtn");
      // create event object
      let event = document.createEvent("MouseEvents");
      // initialize the event object
      event.initMouseEvent("click", true, true, document.defaultView, 
                          0, 0, 0, 0, 0, false, false, false, false, 0, null);
      // fire the event
      btn.dispatchEvent(event);
      ```

7. 动画与Canvas图形
    - requestAnimationFrame()
      ```js
      let enqueued = false;
      function expensiveOperation() {
        console.log('Invoked at', Date.now());
        enqueued = false;
      }
      window.addEventListener('scroll', () => {
        if (!enqueued) {
          enqueued = true;
          window.requestAnimationFrame(expensiveOperation);
        }
      });
      ```
    - 基础的画布功能：getContext() 和 toDataURL()
      ```js
      let drawing = document.getElementById("drawing");
      // make sure <canvas> is completely supported
      if (drawing.getContext) {
        let context = drawing.getContext("2d");
        
        // start the path
        context.beginPath();
              
        // draw outer circle
        context.arc(100, 100, 99, 0, 2 * Math.PI, false);
        
        // draw inner circle
        context.moveTo(194, 100);
        context.arc(100, 100, 94, 0, 2 * Math.PI, false);
              
        // translate to center
        context.translate(100, 100);
        
        // rotate the hands
        context.rotate(1);
              
        // draw minute hand
        context.moveTo(0,0);
        context.lineTo(0, -85);
        
        // draw hour hand
        context.moveTo(0, 0);
        context.lineTo(-65, 0);
        
        // stroke the path
        context.stroke();
      }
      ```

8. 表单脚本
    - form 元素的 submit() 与 reset() 方法 以及 elements属性；
    - 表单字段的公共事件：focus、change、blur事件
    - 文本框编程：input的maxlength属性、textarea的rows和cols属性
    - 处理剪切板：
      ```js
      function getClipboardText(event){
        var clipboardData =  (event.clipboardData || window.clipboardData);
        return clipboardData.getData("text");
      }

      function setClipboardText (event, value){
        if (event.clipboardData){
          return event.clipboardData.setData("text/plain", value);
        } else if (window.clipboardData){
          return window.clipboardData.setData("text", value);
        }
      }
      textbox.addEventListener("paste", (event) => {
        let text = getClipboardText(event);
        if (!/^\d*$/.test(text)){
          event.preventDefault();
        }
      });
      ```
    - 选择框编程
      ```js
      let newOption = new Option("Option text", "Option value");
      selectbox.add(newOption, undefined);    // best solution

      selectbox.options[0].selected = true;
      let selectedOption = selectbox.options[selectbox.selectedIndex];
      ```
    - 表单序列化
      ```js
      function serialize(form) {
        let parts = [];
        let optValue;

        for (let field of form.elements) {
          switch(field.type) {
            case "select-one":
            case "select-multiple":
              if (field.name.length) {
              for (let option of field.options) {
                  if (option.selected) {
                    if (option.hasAttribute){
                      optValue = (option.hasAttribute("value") ? 
                                  option.value : option.text);
                    } else {
                      optValue = (option.attributes["value"].specified ? 
                                  option.value : option.text);
                    }
                    parts.push(encodeURIComponent(field.name)} + "=" +  
                              encodeURIComponent(optValue));
                  }
                }
              }
              break;
            case undefined:     // fieldset
            case "file":        // file input
            case "submit":      // submit button
            case "reset":       // reset button
            case "button":      // custom button
              break;
            case "radio":       // radio button
            case "checkbox":    // checkbox
              if (!field.checked) {
                break;
              }
            default:
              // don't include form fields without names
              if (field.name.length) {
                parts.push(`${encodeURIComponent(field.name)}=` +  
                          `${encodeURIComponent(field.value)}`);

              }
        }     
        return parts.join("&");
      }
      ```
    - 富文本编辑：contenteditable 以及 document.execCommand()

## JavaScript API

1. javascript api:
    - SharedArrayBuffer 与 Atomics
    - 跨上下文消息：postMessage()，接收3个参数：消息、表示目标接收源的字符串、可选的可传输对象的数组(只与工作线程有关)
      ```js
      let iframeWindow = document.getElementById("myframe").contentWindow;
      iframeWindow.postMessage("A secret", "http://www.wrox.com");

      window.addEventListener("message", (event) => {
        // ensure the sender is expected
        if (event.origin == "http://www.wrox.com") {
          // do something with the data
          processMessage(event.data);
          // optional: send a message back to the original window
          event.source.postMessage("Received!", "http://p2p.wrox.com");
        }
      });
      ```
    - Encodeing API: 主要用于实现字符串与定型数组之间的转换  
    - File API 和 Blob API
      1) File类型: html5在dom上为文件输入元素添加了files集合，包含一组File对象，每个file对象都有一些只读属性：name、size、type、lastModifiedDate(这个属性只有chrome实现了)  
      2) FileReader类型: 表示一种异步文件读取机制  
        ```js
        let filesList = document.getElementById("files-list");
        filesList.addEventListener("change", (event) => {
          let info = "",
              output = document.getElementById("output"),
              progress = document.getElementById("progress"),
              files = event.target.files,
              type = "default",
              reader = new FileReader();

          if (/image/.test(files[0].type)) {
            reader.readAsDataURL(files[0]);
            type = "image";
          } else {
            reader.readAsText(files[0]);
            type = "text";
          }

          reader.onerror = function() {
            output.innerHTML = "Could not read file, error code is " + 
                reader.error.code;
          };
          
          reader.onprogress = function(event) {
            if (event.lengthComputable) {
              progress.innerHTML = `${event.loaded}/${event.total}`;
            }
          };
          
          reader.onload = function() {
            let html = "";
            
            switch(type) {
              case "image":
                html = `<img src="${reader.result}">`;
                break;
              case "text":
                html = reader.result;
                break;
            }
            output.innerHTML = html;
          };
        });
        ```
      3) FileReaderSync类型：FileReader的同步版本，只再工作线程中可用  
      4) Blob与部分读取：File对象提供一个名为slice()方法，接收两个参数: 起始字节和要读取的字节，返回一个Blob实例  
      5）对象URL和Blob: window.URL.createObjectURL() 和 window.URL.revokeObjectURL()  
      6) 读取和拖拽文件：drop事件里的：event.dataTransfer,files属性  
      7) 媒体元素：audio 和 video  
      8) 原生拖放：被拖放元素：dragstart、drag、dragend；放置目标：dragenter、dragover、dragleave或drop；html5在所有html元素上规定了一个draggable属性，表示元素是否可以拖动；event.dataTransfer对象  
      9) Streams API
        ```js
        async function* ints() {
          // yield an incremented integer every 1000ms
          for (let i = 0; i < 5; ++i) {
            yield await new Promise((resolve) => setTimeout(resolve, 1000, i));
          }
        }
        const integerStream = new ReadableStream({
          async start(controller) {
            for await (let chunk of ints()) {
              controller.enqueue(chunk);
            }
            controller.close();
          }
        });
        const doublingStream = new TransformStream({
          transform(chunk, controller) {
            controller.enqueue(chunk * 2);
          }
        });
        // Perform stream piping
        const pipedStream = integerStream.pipeThrough(doublingStream);

        // Acquire reader on output of piped streams
        const pipedStreamDefaultReader = pipedStream.getReader();

        // Consumer
        (async function() {
          while(true) {
            const { done, value } = await pipedStreamDefaultReader.read();

            if (done) {
              break;
            } else {
              console.log(value);
            }
          }
        })();
        ```
      10) 计时API：window.performance  
      11) Web 组件：影子dom: attachShadow() 和 自定义元素: customElements.define()
        ```js
        document.body.innerHTML = `<x-foo></x-foo>`;

        class FooElement extends HTMLElement {
          constructor() {
            super();
            this.bar = true;
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `<p>I'm inside a custom element </p>`;
          }
          get bar() {
            return this.getAttribute('bar');
          }
          set bar(value) {
            this.setAttribute('bar', value)
          }
        }
        customElements.define('x-foo', FooElement);

        console.log(document.body.innerHTML);
        ```

2. 错误处理与调试
    - window.onerror 事件：会传入3个参数：错误消息、发生错误的URL、行号；注意error事件没有dom2事件形式  
    - debugger;调试  
3. JSON: stringify() 和 parse()；stringify()可以有3个参数：序列化对象、过滤器(可以是数组或函数)、缩进字符串的选项 

4. 网络请求与远程资源
    - XMLHttpRequest对象：
      1) open()方法，接收3个对象，请求类型、请求URL、以及表示请求是否异步的布尔值  
      2) send()方法，接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传null;  
      3) 收到响应后，xhr对象的以下属性会被填充上数据：responseText、responseXML、status、statusText；  
      4) 可以使用setRequestHeader()方法发送额外头部，必须在open()之后、send()之前调用；而getResponseHeader() 和 getAllResponseHeaders()获取响应头部；  
      5) post请求需要设置content-type 头部为 application/x-www-form-urlencoded；  
        ```js
        let xhr = new XMLHttpRequest();    
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
              alert(xhr.responseText);
            } else {
              alert("Request was unsuccessful: " + xhr.status);
            }
          }
        };
        xhr.open("post", "postexample.php", true);
        let form = document.getElementById("user-info");      
        xhr.send(new FormData(form)); 
        ```
      6) FormData类型: append()方法；使用FormData不需要给XHR对象显示的设置任何请求头部了；  
      7) 超时：xhr.timeout 以及 xhr.ontimeout，不过虽然会除非ontimeout事件，但是readyState仍然会变成4，会调用onreadystatechange事件，不过如果在超时或访问status属性会发生错误，需要封装try/catch语句；  

    - 进度事件：浏览器支持度不一致: loadstart、progress、error、abort、load、loadend
        ```js
        let xhr = new XMLHttpRequest();    
        xhr.onload = function(event) {
          if ((xhr.status >= 200 && xhr.status < 300) || 
              xhr.status == 304) {
            alert(xhr.responseText);
          } else {
            alert("Request was unsuccessful: " + xhr.status);
          }
        };
        xhr.onprogress = function(event) {
          let divStatus = document.getElementById("status");
          if (event.lengthComputable) {
            divStatus.innerHTML = "Received " + event.position + " of " + 
              event.totalSize + 
        " bytes";
          }
        };
        xhr.timeout = 1000;  // set timeout for 1 second
        xhr.ontimeout = function() {
          alert("Request did not return in a second.");
        };
        xhr.open("get", "altevents.php", true);
        xhr.send(null); 
        ```
    - 跨源资源共享：cors,基本思路是使用自定义的HTTP头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败  
      1) 浏览器会在发送时会有一个额外的头部Oigin，包括请求页面的源，如果服务器决定响应请求，那么应该发生Access-Control-Allow-Origin头部，包含相同的源，或者如果资源是公开的，那么就包含’*‘；  
      2) 出于安全考虑，跨域XHR对象也施加了一些额外限制：不能使用setRequestHeader()设置自定头部；不能接收和发送cookie；getAllResponseHeaders()方法始终返回空字符串；  
      3) 预检请求：OPTIONS方法发送  
      4) 凭据请求：请求设置 withCredentials属性设置为true，服务器响应包含 Access-Control-Allow-Credentials  
    
    - 替代性跨源技术
      1) 图片探测：与服务器之间的简单、跨域、单向的通信，浏览器通过图片探测拿不到任何数据，但是可以通过监听onload、onerror事件知道什么时候能得到响应；  
      2) JSONP: 动态创建script标签并为src属性指定跨域URL实现的；缺点是不好确定jsonp请求是否失败，html5规定的script的onerror事件处理程序，还没有被任何浏览器实现(`待查证todo?`)  

    - Fetch API：
      1) fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程，可接受2个参数：必须的获取资源的URL、参数init对象；请求完成、资源可用时，期约会解决为一个Response对象  
      2) Headers对象、Request对象、Response对象  
        ```js
        fetch('https://foo.com')
          .then((response) => response.text())
          .then(console.log);
        ```
    - Web Socket: 长时连接实现与服务器全双工、双向的通信
      1) 在js中创建web socket时，一个http请求会发生到服务器以初始化连接，服务器响应后，连接使用http的update头部从http协议切换到web socket协议；  
      2) 同源策略不适用于web socket
        ```js
        let socket = new WebSocket("ws://www.example.com/server.php");
        socket.onmessage = function(event) {
          let data = event.data;
          // do something with data
        };
        socket.onopen = function() {
          alert("Connection established.");
        };
        socket.onerror = function() {
          alert("Connection error.");
        };
        socket.onclose = function() {
          alert("Connection closed.");
        }; 
        let stringData = "Hello world!";
        let arrayBufferData = Uint8Array.from(['f', 'o' 'o']);
        let blobData = new Blob(['f', 'o' 'o']);

        socket.send(stringData);
        socket.send(arrayBufferData.buffer);
        socket.send(blobData);
        ```

5. 客户端存储
    - cookie: name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure 
    - web storage: sessionStorage：会话数据，只会存储到浏览器关闭；localStorage：页面必须来着同一个域、在相同的端口上使用相同的协议
    - indexedDB: open() 方法  
      ```js
      let request, database;
      request = indexedDB.open("admin", 1);
      request.onsuccess = (event) => {
        database = event.target.result;
        database.onversionchange = () => database.close();
      }; 
      ```

6. 模块：IIFE(立即调用函数表达式) 、commonJS 、AMD、UMD、ES6模块
7. 工作者线程
    - 在工作者线程内部，没有window的概率。这里的全局对象时WorkerGlobalScope的实例，通过self关键字暴露出来  
    - 专用工作者线程Worker: 事件 onerror、onmessage、onmessageerror；方法 postMessage() terminate()  
      ```js
      // factorialWorker.js
      function factorial(n) {
        let result = 1;
        while(n) { result *= n--; }
        return result;
      }
      self.onmessage = ({data}) => {
        self.postMessage(`${data}! = ${factorial(data)}`);
      };

      // main.js
      const factorialWorker = new Worker('./factorialWorker.js');

      factorialWorker.onmessage = ({data}) => console.log(data);

      factorialWorker.postMessage(5);
      factorialWorker.postMessage(7);
      factorialWorker.postMessage(10);

      // 5! = 120
      // 7! = 5040
      // 10! = 3628800
      ```
    - 在js行内创建工作者线程
      ```js
      function fibonacci(n) {
        return n < 1 ? 0
            : n <= 2 ? 1
            : fibonacci(n - 1) + fibonacci(n - 2);
      }
      const workerScript = `
        self.postMessage(
          (${fibonacci.toString()})(9)
        );
      `;
      const worker = new Worker(URL.createObjectURL(new Blob([workerScript])));
      worker.onmessage = ({data}) => console.log(data);
      ```
    - 工作者线程中可以使用 importScripts()方法通过编程方法加载和执行任何脚本  
    - MessageChannel: 实例有两个端口，分别代表两个通信端点；MessageChannel真正有用的地方是让两个工作者线程之间直接通信，这可以通过把端口传到另一个工作者线程实现  
      ```js
      // main.js
      const channel = new MessageChannel();
      const workerA = new Worker('./worker.js');
      const workerB = new Worker('./worker.js');

      workerA.postMessage('workerA', [channel.port1]);
      workerB.postMessage('workerB', [channel.port2]);

      workerA.onmessage = ({data}) => console.log(data);
      workerB.onmessage = ({data}) => console.log(data);

      workerA.postMessage(['page']); // ['page', 'workerA', 'workerB']

      workerB.postMessage(['page']) // ['page', 'workerB', 'workerA']

      // worker.js
      let messagePort = null;
      let contextIdentifier = null;

      function addContextAndSend(data, destination) {
        // Add identifier to show when it reached this worker
        data.push(contextIdentifier);

        // 把数据发送到下一个目标
        destination.postMessage(data);
      }

      self.onmessage = ({data, ports}) => {
        // If ports exist in the message,
        // set up the worker
        if (ports.length) {
          // Record the identifier
          contextIdentifier = data;

          // Capture the MessagePort
          messagePort = ports[0];

          // 添加处理程序把接收到的数据发送到父页面
          messagePort.onmessage = ({data}) => {
            addContextAndSend(data, self);
          }
        } else {
          addContextAndSend(data, messagePort);
        }
      };
      ```
    - 线程池
      ```js
      class TaskWorker extends Worker {
        constructor(notifyAvailable, ...workerArgs) {
          super(...workerArgs);

          // Initialize as unavailable
          this.available = false;
          this.resolve = null;
          this.reject = null;

          // Worker pool will pass a callback so that the
          // worker can signal it needs another task
          this.notifyAvailable = notifyAvailable;

          // Worker script will send a 'ready' postmessage 
          // once fully initialized
          this.onmessage = () => this.setAvailable();
        }

        // Called by the worker pool to begin a new task
        dispatch({ resolve, reject, postMessageArgs }) {
          this.available = false;

          this.onmessage = ({ data }) => {
            resolve(data);
            this.setAvailable();
          };

          this.onerror = (e) => {
            reject(e);
            this.setAvailable();
          };

          this.postMessage(...postMessageArgs);
        }

        setAvailable() {
          this.available = true;
          this.resolve = null;
          this.reject = null;
          this.notifyAvailable();
        }
      }

      class WorkerPool {
        constructor(poolSize, ...workerArgs) {
          this.taskQueue = [];
          this.workers = [];

          // Initialize the worker pool
          for (let i = 0; i < poolSize; ++i) {
            this.workers.push(
              new TaskWorker(() => this.dispatchIfAvailable(), ...workerArgs));
          }
        }

        // Pushes a task onto the queue
        enqueue(...postMessageArgs) {
          return new Promise((resolve, reject) => {
            this.taskQueue.push({ resolve, reject, postMessageArgs });

            this.dispatchIfAvailable();
          });
        }

        // Sends a task to the next available worker if there is one
        dispatchIfAvailable() {
          if (!this.taskQueue.length) {
            return;
          }
          for (const worker of this.workers) {
            if (worker.available) {
              let a = this.taskQueue.shift();
              worker.dispatch(a);
              break;
            }
          }
        }

        // Kills all the workers
        close() {
          for (const worker of this.workers) {
            worker.terminate();
          }
        }
      }

      // ----worker.js
      self.onmessage = ({data}) => {
        let sum = 0;
        let view = new Float32Array(data.arrayBuffer)
        // Perform sum
        for (let i = data.startIdx; i < data.endIdx; ++i) {
          // No need for Atomics since only performing reads
          sum += view[i];
        }
        // Send the result to the worker
        self.postMessage(sum);
      };
      // Send messagemessate to TaskWorker to signal worker is
      // ready to receive tasks.
      self.postMessage('ready');

      // ---main.js
      const totalFloats = 1E8;
      const numTasks = 20;
      const floatsPerTask = totalFloats / numTasks;
      const numWorkers = 4;

      // Create pool
      const pool = new WorkerPool(numWorkers, './worker.js');

      // Fill array of floats
      let arrayBuffer = new SharedArrayBuffer(4 * totalFloats);
      let view = new Float32Array(arrayBuffer);
      for (let i = 0; i < totalFloats; ++i) {
        view[i] = Math.random();
      }

      let partialSumPromises = [];
      for (let i = 0; i < totalFloats; i += floatsPerTask) {
        partialSumPromises.push(
          pool.enqueue({
            startIdx: i,
            endIdx: i + floatsPerTask,
            arrayBuffer: arrayBuffer
          })
        );
      }

      // Wait for all promises to complete, then sum
      Promise.all(partialSumPromises)
        .then((partialSums) => partialSums.reduce((x, y) => x + y))
        .then(console.log);

      // (In this example, sum should be roughly 1E8/2)
      // 49997075.47203197 
      ```

